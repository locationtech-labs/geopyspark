diff --git a/config/geonotebook.ini b/config/geonotebook.ini
index 6ff4b8d..c88173f 100644
--- a/config/geonotebook.ini
+++ b/config/geonotebook.ini
@@ -2,6 +2,9 @@
 vis_server = ktile
 log_level = WARNING
 
+[geotrellis]
+url = http://127.0.0.1:8000/user/jack/geotrellis
+
 [geoserver]
 username = admin
 password = geoserver
diff --git a/geonotebook/config.py b/geonotebook/config.py
index d2c2b9e..19edcbc 100644
--- a/geonotebook/config.py
+++ b/geonotebook/config.py
@@ -13,6 +13,7 @@ def get_config(path=None):
         "/etc/geonotebook.ini",
         "/usr/etc/geonotebook.ini",
         "/usr/local/etc/geonotebook.ini",
+        "~/.local/etc/geonotebook.ini",
         os.path.join(sys.prefix, "etc/geonotebook.ini"),
         "~/.geonotebook.ini",
         os.path.join(os.getcwd(), ".geonotebook.ini"),
diff --git a/geonotebook/kernel.py b/geonotebook/kernel.py
index 1e742d5..4bb6869 100644
--- a/geonotebook/kernel.py
+++ b/geonotebook/kernel.py
@@ -19,7 +19,7 @@ from .layers import (AnnotationLayer,
                      VectorLayer)
 
 from .utils import get_kernel_id
-from .wrappers import RasterData, RasterDataCollection, VectorData
+from .wrappers import RddRasterData, RasterData, RasterDataCollection, VectorData
 
 
 class Remote(object):
@@ -392,7 +392,13 @@ class Geonotebook(object):
             kwargs['zIndex'] = len(self.layers)
 
         # HACK:  figure out a way to do this without so many conditionals
-        if isinstance(data, RasterData):
+        if isinstance(data, RddRasterData):
+            name = data.name
+
+            layer = SimpleLayer(
+                name, self._remote, data=data, vis_url=vis_url, **kwargs
+            )
+        elif isinstance(data, RasterData):
             # TODO verify layer exists in geoserver?
             name = data.name if name is None else name
 
@@ -438,8 +444,11 @@ class Geonotebook(object):
         if hasattr(layer_name, 'name'):
             layer_name = layer_name.name
 
-        def _remove_layer(layer_name):
-            self.layers.remove(layer_name)
+        def _remove_layer(_layer_name):
+            vis_server = Config().vis_server
+            if "disgorge" in dir(vis_server):
+                vis_server.disgorge(layer_name)
+            self.layers.remove(_layer_name)
 
         cb = self._remote.remove_layer(layer_name).then(
             _remove_layer, self.rpc_error).catch(self.callback_error)
diff --git a/geonotebook/layers.py b/geonotebook/layers.py
index 0e73741..52ee74c 100644
--- a/geonotebook/layers.py
+++ b/geonotebook/layers.py
@@ -232,7 +232,8 @@ class SimpleLayer(DataLayer):
 
         if vis_url is None:
             self.vis_url = self.config.vis_server.ingest(
-                self.data, name=self.name, **self.vis_options.serialize())
+                self.data, name=self.name, \
+                **self.vis_options.serialize())
         else:
             self.vis_url = vis_url
 
diff --git a/geonotebook/vis/__init__.py b/geonotebook/vis/__init__.py
index 0ce34fc..1483a02 100644
--- a/geonotebook/vis/__init__.py
+++ b/geonotebook/vis/__init__.py
@@ -1,4 +1,5 @@
 from .geoserver import Geoserver
 from .ktile import Ktile
+from .geotrellis import GeoTrellis
 
-__all__ = ('Geoserver', 'Ktile')
+__all__ = ('Geoserver', 'Ktile', 'GeoTrellis')
diff --git a/geonotebook/vis/geotrellis/__init__.py b/geonotebook/vis/geotrellis/__init__.py
new file mode 100644
index 0000000..3e3a150
--- /dev/null
+++ b/geonotebook/vis/geotrellis/__init__.py
@@ -0,0 +1,3 @@
+from .geotrellis import GeoTrellis
+
+__all__ = ('GeoTrellis')
diff --git a/geonotebook/vis/geotrellis/geotrellis.py b/geonotebook/vis/geotrellis/geotrellis.py
new file mode 100644
index 0000000..9661406
--- /dev/null
+++ b/geonotebook/vis/geotrellis/geotrellis.py
@@ -0,0 +1,96 @@
+import requests
+import threading
+import time
+
+from notebook.base.handlers import IPythonHandler
+from random import randint
+from .server import moop
+
+
+# jupyterhub --no-ssl --Spawner.notebook_dir=/home/hadoop
+
+class GeoTrellisHandler(IPythonHandler):
+
+    def initialize(self):
+        pass
+
+    def get(self, port, layer_name, x, y, zoom, **kwargs):
+        url = "http://localhost:%s/tile/%s/%s/%s/%s.png" % (port, layer_name, x, y, zoom)
+        try:
+            response = requests.get(url)
+            if response.status_code == requests.codes.ok:
+                png = response.content
+                self.set_header('Content-Type', 'image/png')
+                self.write(png)
+                self.finish()
+            else:
+                self.set_header('Content-Type', 'text/html')
+                self.set_status(404)
+                self.finish()
+        except:
+            self.set_header('Content-Type', 'text/png')
+            self.set_status(404)
+            self.finish()
+
+class GeoTrellis(object):
+
+    def __init__(self, config, url):
+        self.base_url = url
+        self.pyramids = {}
+        self.server_active = False
+        self.port = randint(49152, 65535) # XXX
+
+    def start_kernel(self, kernel):
+        pass
+
+    def shutdown_kernel(self, kernel):
+        pass
+
+    def initialize_webapp(self, config, webapp):
+        pattern = r'/user/[^/]+/geotrellis/([0-9]+)/([^/]+)/([0-9]+)/([0-9]+)/([0-9]+)\.png.*'
+        webapp.add_handlers(r'.*', [(pattern, GeoTrellisHandler)])
+
+    def get_params(self, name, data, **kwargs):
+        return {}
+
+    def disgorge(self, name):
+        url = "http://localhost:%s/remove/%s" % (self.port, name)
+        response = requests.get(url)
+        status_code = response.status_code
+        print(status_code)
+        return status_code
+
+    def ingest(self, data, name, **kwargs):
+        from geopyspark.geotrellis.rdd import RasterRDD, TiledRasterRDD
+        from geopyspark.geotrellis.render import PngRDD
+        # from geopyspark.geotrellis.constants import ZOOM
+
+        rdd = data.rdd
+        if isinstance(rdd, RasterRDD):
+            metadata = rdd.collect_metadata()
+            laid_out = rdd.tile_to_layout(metadata)
+            # reprojected = laid_out.reproject("EPSG:3857", scheme=ZOOM)
+            png = PngRDD.makePyramid(laid_out, data.rampname)
+        elif isinstance(rdd, TiledRasterRDD):
+            laid_out = rdd
+            # reprojected = laid_out.reproject("EPSG:3857", scheme=ZOOM)
+            png = PngRDD.makePyramid(laid_out, data.rampname)
+        elif isinstance(rdd, PngRDD):
+            png = rdd
+        else:
+            raise Exception
+
+        # rdds = {}
+        # for layer_rdd in reprojected.pyramid(reprojected.zoom_level, 0):
+        #     rdds[layer_rdd.zoom_level] = layer_rdd
+        # # self.pyramids.update({name: rdds})
+        # self.pyramids[name] = rdds
+
+        # if self.server_active == False:
+        t = threading.Thread(target=moop, args=(png, # self.pyramids
+                                                self.port))
+        t.start()
+        #  self.server_active = True
+
+        self.base_url = "http://localhost:8000/user/hadoop/geotrellis" # XXX
+        return self.base_url + "/" + str(self.port) + "/" + name
diff --git a/geonotebook/vis/geotrellis/server.py b/geonotebook/vis/geotrellis/server.py
new file mode 100644
index 0000000..588b5fc
--- /dev/null
+++ b/geonotebook/vis/geotrellis/server.py
@@ -0,0 +1,108 @@
+import io
+import numpy as np
+import rasterio
+import threading
+import time
+
+from PIL import Image, ImageDraw, ImageFont
+
+
+def make_image(arr):
+    return Image.fromarray(arr.astype('uint8')).convert('L')
+
+def clamp(x):
+    if (x < 0.0):
+        x = 0
+    elif (x >= 1.0):
+        x = 255
+    else:
+        x = (int)(x * 255)
+    return x
+
+def alpha(x):
+    if ((x <= 0.0) or (x > 1.0)):
+        return 0
+    else:
+        return 255
+
+clamp = np.vectorize(clamp)
+alpha = np.vectorize(alpha)
+lock = threading.Lock()
+
+def moop(png, port):
+    from flask import Flask, make_response, abort
+
+    app = Flask(__name__)
+    app.reader = None
+
+    @app.route("/time")
+    def ping():
+        return time.strftime("%H:%M:%S") + "\n"
+
+
+    # @app.route("/exists/<layer_name>")
+    # def exists(layer_name):
+    #     return str(layer_name in pyramids) + "\n"
+
+    # @app.route("/remove/<layer_name>")
+    # def remove(layer_name):
+    #     if layer_name in pyramids:
+    #         del pyramids[layer_name]
+    #         return "yes\n"
+    #     else:
+    #         return "no\n"
+
+    @app.route("/tile/<layer_name>/<int:x>/<int:y>/<int:zoom>.png")
+    def tile(layer_name, x, y, zoom):
+
+        # fetch data
+        try:
+            # pyramid = pyramids[layer_name]
+            # rdd = pyramid[zoom]
+            img = png.lookup(x, y, zoom)
+            # arr = tile[0]['data']
+            # nodata = -32768 #tile[0]['no_data_value']
+        except:
+            img = None
+
+        if img == None or len(img) == 0:
+            # abort(404)
+            image = Image.new('RGBA', (256,256))
+            draw = ImageDraw.Draw(image)
+            draw.rectangle([0, 0, 255, 255], outline=(255,0,0,255))
+            draw.line([(0,0),(255,255)], fill=(255,0,0,255))
+            draw.line([(0,255),(255,0)], fill=(255,0,0,255))
+            draw.text((136,122), str(13) + ', ' + str(12), fill=(255,0,0,255))
+            del draw
+            bio = io.BytesIO()
+            image.save(bio, 'PNG')
+            img = [bio.getvalue()]
+
+        # bands = arr.shape[0]
+        # if bands >= 3:
+        #     bands = 3
+        # else:
+        #     bands = 1
+        # arrs = [np.array(arr[i, :, :]).reshape(256, 256) for i in range(bands)]
+
+        # # create tile
+        # if bands == 3:
+        #     images = [make_image(clamp(remap(arr))) for arr in arrs]
+        #     alfa = alpha(arrs[0])
+        #     # alfa[arrs[0] == nodata] = 0
+        #     images.append(make_image(alfa))
+        #     image = Image.merge('RGBA', images)
+        # else:
+        #     gray = make_image(clamp(remap(arrs[0])))
+        #     alfa = alpha(arrs[0])
+        #     # alfa[arrs[0] == nodata] = 0
+        #     image = Image.merge('RGBA', list(gray, gray, gray, make_image(alfa)))
+
+        # return tile
+        #bio = io.BytesIO(img[0])
+        #Image.open(bio)
+        response = make_response(img[0])
+        response.headers['Content-Type'] = 'image/png'
+        return response
+
+    app.run(host='0.0.0.0', port=port)
diff --git a/geonotebook/wrappers/__init__.py b/geonotebook/wrappers/__init__.py
index f95e8af..6a0e86b 100644
--- a/geonotebook/wrappers/__init__.py
+++ b/geonotebook/wrappers/__init__.py
@@ -1,5 +1,5 @@
-from .raster import RasterData, RasterDataCollection
+from .raster import RddRasterData, RasterData, RasterDataCollection
 from .vector import VectorData
 
 
-__all__ = ('RasterData', 'RasterDataCollection', 'VectorData')
+__all__ = ('RddRasterData', 'RasterData', 'RasterDataCollection', 'VectorData')
diff --git a/geonotebook/wrappers/raster.py b/geonotebook/wrappers/raster.py
index b2a83d3..8f192f2 100644
--- a/geonotebook/wrappers/raster.py
+++ b/geonotebook/wrappers/raster.py
@@ -9,6 +9,24 @@ import pkg_resources as pr
 from shapely.geometry import Polygon
 
 
+class RddRasterData(object):
+
+    def __init__(self, rdd, name=None, rampname="Viridis"):
+        from geopyspark.geotrellis.rdd import RasterRDD, TiledRasterRDD
+        from geopyspark.geotrellis.render import PngRDD
+
+        if not (isinstance(rdd, RasterRDD) or isinstance(rdd, TiledRasterRDD) or isinstance(rdd, PngRDD)):
+            raise Exception
+
+        self.rdd = rdd
+
+        self.rampname = rampname
+
+        if not name:
+            self.name = str(abs(hash(rdd) + hash(rampname)))
+        else:
+            self.name = name
+
 class RasterData(collections.Sequence):
     _default_schema = 'file'
 
diff --git a/setup.py b/setup.py
index 58d60fa..51f2329 100644
--- a/setup.py
+++ b/setup.py
@@ -19,21 +19,21 @@ from setuptools.command.sdist import sdist
 
 PY3 = (sys.version_info[0] >= 3)
 
-if PY3:
-    try:
-        import mapnik # noqa
-    except ImportError:
-        print("""
-
-Python bindings for Mapnik (https://github.com/mapnik/python-mapnik) are
-required to run GeoNotebook. Unfortunately there are no pip install-able
-versions of the bindings for Python 3. The Mapnik bindings will compile
-under Python 3 but they must be compiled and installed from source.
-Please follow the instructions on the mapnik/python-mapnik repository,
-ensuring you can import mapnik before continuing to install GeoNotebook
-using Python 3.
-        """)
-        sys.exit(1)
+# if PY3:
+#     try:
+#         import mapnik # noqa
+#     except ImportError:
+#         print("""
+
+# Python bindings for Mapnik (https://github.com/mapnik/python-mapnik) are
+# required to run GeoNotebook. Unfortunately there are no pip install-able
+# versions of the bindings for Python 3. The Mapnik bindings will compile
+# under Python 3 but they must be compiled and installed from source.
+# Please follow the instructions on the mapnik/python-mapnik repository,
+# ensuring you can import mapnik before continuing to install GeoNotebook
+# using Python 3.
+#         """)
+#         sys.exit(1)
 
 
 def post_install(func, **kwargs):
@@ -75,8 +75,12 @@ def install_kernel(cmd):
         json.dump(kernel_dict, fh, indent=1)
 
     ksm = KernelSpecManager()
-    ksm.install_kernel_spec(
-        path, kernel_name=kernel_name, user=False, prefix=sys.prefix)
+    try:
+        ksm.install_kernel_spec(
+            path, kernel_name=kernel_name, user=False, prefix=sys.prefix)
+    except:
+        ksm.install_kernel_spec(
+            path, kernel_name=kernel_name, user=True)
 
     shutil.rmtree(path)
 
@@ -273,7 +277,7 @@ setup(
         "jupyter_client",
         "notebook",
         "fiona",
-        "mapnik",
+        # "mapnik",
         "shapely"
     ],
     cmdclass={
@@ -311,7 +315,8 @@ setup(
         ],
         'geonotebook.vis.server': [
             "geoserver = geonotebook.vis.geoserver:Geoserver",
-            "ktile = geonotebook.vis.ktile:Ktile"
+            "ktile = geonotebook.vis.ktile:Ktile",
+            "geotrellis = geonotebook.vis.geotrellis:GeoTrellis"
         ],
     }
 )
